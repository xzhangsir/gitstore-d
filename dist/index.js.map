{
  "version": 3,
  "sources": ["../src/index.js", "../src/utils.js"],
  "sourcesContent": ["import fs from 'fs'\r\nimport path from 'path'\r\nimport { mkdirp, base, exec } from './utils'\r\n\r\nmodule.exports = function gitD(src, opts) {\r\n  return new GitD(src, opts)\r\n}\r\n// export default function gitD(src, opts) {\r\n//   return new GitD(src, opts)\r\n// }\r\n\r\nclass GitD {\r\n  constructor(src, opts = {}) {\r\n    this.src = src\r\n    this.proxy = process.env.https_proxy\r\n    this.force = opts.force || false\r\n    this.repo = parse(src)\r\n    // this.mode = opts.mode || this.repo.mode\r\n  }\r\n  async clone(dest) {\r\n    // \u67E5\u770B\u76EE\u5F55\u662F\u4E0D\u662F\u7A7A\u7684\r\n    this._checkDirIsEmpty(dest)\r\n    // const { repo } = this\r\n    // const dir = path.join(base, repo.site, repo.user, repo.name)\r\n    await this._cloneWithGit(dest)\r\n\r\n    // console.log('clone')\r\n  }\r\n  _checkDirIsEmpty(dir) {\r\n    try {\r\n      // console.log(dir)\r\n      const files = fs.readdirSync(dir)\r\n      // console.log(files)\r\n      if (files.length > 0) {\r\n        if (this.force) {\r\n          // this._info({\r\n          //   code: 'DEST_NOT_EMPTY',\r\n          //   message: `destination directory is not empty. Using options.force, continuing`\r\n          // })\r\n          console.log('\u76EE\u6807\u76EE\u5F55\u4E0D\u4E3A\u7A7A\u3002\u4F7F\u7528force\u9009\u9879\u7EE7\u7EED')\r\n        } else {\r\n          // throw new DegitError(\r\n          //   `destination directory is not empty, aborting. Use options.force to override`,\r\n          //   {\r\n          //     code: 'DEST_NOT_EMPTY'\r\n          //   }\r\n          // )\r\n          console.log('\u76EE\u6807\u76EE\u5F55\u4E0D\u4E3A\u7A7A')\r\n        }\r\n      } else {\r\n        // this._verbose({\r\n        //   code: 'DIR_IS_EMPTY',\r\n        //   message: `destination directory is empty`\r\n        // })\r\n        console.log('success')\r\n      }\r\n    } catch (err) {\r\n      if (err.code !== 'ENOENT') throw err\r\n    }\r\n  }\r\n  async _cloneWithGit(dest) {\r\n    // await exec(`git clone ${this.repo.url} ${dest}`)\r\n    await exec(`git clone https://gitee.com/zxwaa/feisen.git ${dest}`)\r\n    await exec(`rm -rf ${dest + '/.git*'}`)\r\n  }\r\n}\r\n\r\nconst supported = new Set([\r\n  'github',\r\n  'gitee',\r\n  'gitlab',\r\n  'bitbucket',\r\n  'git.sr.ht'\r\n])\r\n\r\nfunction parse(src) {\r\n  const match =\r\n    /^(?:(?:https:\\/\\/)?([^:/]+\\.[^:/]+)\\/|git@([^:/]+)[:/]|([^/]+):)?([^/\\s]+)\\/([^/\\s#]+)(?:((?:\\/[^/\\s#]+)+))?(?:\\/)?(?:#(.+))?/.exec(\r\n      src\r\n    )\r\n  if (!match) {\r\n    // throw new DegitError(`could not parse ${src}`, {\r\n    //   code: 'BAD_SRC'\r\n    // })\r\n  }\r\n\r\n  const site = (match[1] || match[2] || match[3] || 'github').replace(\r\n    /\\.(com|org)$/,\r\n    ''\r\n  )\r\n  if (!supported.has(site)) {\r\n    // throw new DegitError(\r\n    //   `degit supports GitHub, GitLab, Sourcehut and BitBucket`,\r\n    //   {\r\n    //     code: 'UNSUPPORTED_HOST'\r\n    //   }\r\n    // )\r\n  }\r\n\r\n  const user = match[4]\r\n  const name = match[5].replace(/\\.git$/, '')\r\n  const subdir = match[6]\r\n  const ref = match[7] || 'HEAD'\r\n\r\n  const domain = `${site}.${\r\n    site === 'bitbucket' ? 'org' : site === 'git.sr.ht' ? '' : 'com'\r\n  }`\r\n  const url = `https://${domain}/${user}/${name}`\r\n  const ssh = `git@${domain}:${user}/${name}`\r\n\r\n  const mode = supported.has(site) ? 'tar' : 'git'\r\n\r\n  return { site, user, name, ref, url, ssh, subdir, mode }\r\n}\r\n", "import fs from 'fs'\r\nimport path from 'path'\r\nimport { homedir, tmpdir } from 'os'\r\nimport child_process from 'child_process'\r\nexport const base = path.join(homedir() || tmpdir())\r\n\r\nexport function mkdirp(dir) {\r\n  const parent = path.dirname(dir)\r\n  if (parent === dir) return\r\n\r\n  mkdirp(parent)\r\n\r\n  try {\r\n    fs.mkdirSync(dir)\r\n  } catch (err) {\r\n    if (err.code !== 'EEXIST') throw err\r\n  }\r\n}\r\n\r\nexport function exec(command) {\r\n  return new Promise((resolve, reject) => {\r\n    child_process.exec(command, (err, stdout, stderr) => {\r\n      if (err) {\r\n        reject(err)\r\n        return\r\n      }\r\n      resolve({ stdout, stderr })\r\n    })\r\n  })\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA,gBAAe;;;ACCf,kBAAiB;AACjB,gBAAgC;AAChC,2BAA0B;AACnB,IAAM,OAAO,YAAAA,QAAK,SAAK,mBAAQ,SAAK,kBAAO,CAAC;AAe5C,SAAS,KAAK,SAAS;AAC5B,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,yBAAAC,QAAc,KAAK,SAAS,CAAC,KAAK,QAAQ,WAAW;AACnD,UAAI,KAAK;AACP,eAAO,GAAG;AACV;AAAA,MACF;AACA,cAAQ,EAAE,QAAQ,OAAO,CAAC;AAAA,IAC5B,CAAC;AAAA,EACH,CAAC;AACH;;;ADzBA,OAAO,UAAU,SAAS,KAAK,KAAK,MAAM;AACxC,SAAO,IAAI,KAAK,KAAK,IAAI;AAC3B;AAKA,IAAM,OAAN,MAAW;AAAA,EACT,YAAY,KAAK,OAAO,CAAC,GAAG;AAC1B,SAAK,MAAM;AACX,SAAK,QAAQ,QAAQ,IAAI;AACzB,SAAK,QAAQ,KAAK,SAAS;AAC3B,SAAK,OAAO,MAAM,GAAG;AAAA,EAEvB;AAAA,EACA,MAAM,MAAM,MAAM;AAEhB,SAAK,iBAAiB,IAAI;AAG1B,UAAM,KAAK,cAAc,IAAI;AAAA,EAG/B;AAAA,EACA,iBAAiB,KAAK;AACpB,QAAI;AAEF,YAAM,QAAQ,UAAAC,QAAG,YAAY,GAAG;AAEhC,UAAI,MAAM,SAAS,GAAG;AACpB,YAAI,KAAK,OAAO;AAKd,kBAAQ,IAAI,2FAAqB;AAAA,QACnC,OAAO;AAOL,kBAAQ,IAAI,4CAAS;AAAA,QACvB;AAAA,MACF,OAAO;AAKL,gBAAQ,IAAI,SAAS;AAAA,MACvB;AAAA,IACF,SAAS,KAAP;AACA,UAAI,IAAI,SAAS;AAAU,cAAM;AAAA,IACnC;AAAA,EACF;AAAA,EACA,MAAM,cAAc,MAAM;AAExB,UAAM,KAAK,gDAAgD,MAAM;AACjE,UAAM,KAAK,UAAU,OAAO,UAAU;AAAA,EACxC;AACF;AAEA,IAAM,YAAY,oBAAI,IAAI;AAAA,EACxB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAED,SAAS,MAAM,KAAK;AAClB,QAAM,QACJ,gIAAgI;AAAA,IAC9H;AAAA,EACF;AACF,MAAI,CAAC,OAAO;AAAA,EAIZ;AAEA,QAAM,QAAQ,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,UAAU;AAAA,IAC1D;AAAA,IACA;AAAA,EACF;AACA,MAAI,CAAC,UAAU,IAAI,IAAI,GAAG;AAAA,EAO1B;AAEA,QAAM,OAAO,MAAM;AACnB,QAAM,OAAO,MAAM,GAAG,QAAQ,UAAU,EAAE;AAC1C,QAAM,SAAS,MAAM;AACrB,QAAM,MAAM,MAAM,MAAM;AAExB,QAAM,SAAS,GAAG,QAChB,SAAS,cAAc,QAAQ,SAAS,cAAc,KAAK;AAE7D,QAAM,MAAM,WAAW,UAAU,QAAQ;AACzC,QAAM,MAAM,OAAO,UAAU,QAAQ;AAErC,QAAM,OAAO,UAAU,IAAI,IAAI,IAAI,QAAQ;AAE3C,SAAO,EAAE,MAAM,MAAM,MAAM,KAAK,KAAK,KAAK,QAAQ,KAAK;AACzD;",
  "names": ["path", "child_process", "fs"]
}
