{
  "version": 3,
  "sources": ["../src/index.js", "../src/utils.js"],
  "sourcesContent": ["import fs from 'fs'\r\nimport path from 'path'\r\nimport { mkdirp, base, exec } from './utils'\r\n\r\nmodule.exports = function gitD(src, opts) {\r\n  return new GitD(src, opts)\r\n}\r\n// export default function gitD(src, opts) {\r\n//   return new GitD(src, opts)\r\n// }\r\n\r\nclass GitD {\r\n  constructor(src, opts = {}) {\r\n    this.src = src\r\n    this.proxy = process.env.https_proxy\r\n    this.force = opts.force || false\r\n    // this.repo = parse(src)\r\n    this.repo = normalize(src)\r\n    // this.mode = opts.mode || this.repo.mode\r\n  }\r\n  async clone(dest) {\r\n    console.log(this.repo)\r\n    try {\r\n      // \u67E5\u770B\u76EE\u5F55\u662F\u4E0D\u662F\u7A7A\u7684\r\n      this._checkDirIsEmpty(dest)\r\n      await this._cloneWithGit(dest)\r\n    } catch (error) {\r\n      throw error\r\n    }\r\n\r\n    // const { repo } = this\r\n    // const dir = path.join(base, repo.site, repo.user, repo.name)\r\n    // await this._cloneWithGit(dest)\r\n\r\n    // console.log('clone')\r\n  }\r\n  async _checkDirIsEmpty(dir) {\r\n    try {\r\n      const files = fs.readdirSync(dir)\r\n      if (files.length > 0) {\r\n        if (this.force) {\r\n          await exec(`rm -rf ${dir}`)\r\n        } else {\r\n          // throw new Error('\u76EE\u6807\u76EE\u5F55\u4E0D\u4E3A\u7A7A')\r\n          throw '\u76EE\u6807\u76EE\u5F55\u4E0D\u4E3A\u7A7A'\r\n        }\r\n      }\r\n    } catch (err) {\r\n      if (err.code !== 'ENOENT') throw err\r\n    }\r\n  }\r\n  async _cloneWithGit(dest) {\r\n    await exec(`git clone ${this.repo.url} ${dest}`)\r\n    // await exec(`git clone https://gitee.com/zxwaa/feisen.git ${dest}`)\r\n    await exec(`rm -rf ${dest + '/.git*'}`)\r\n  }\r\n}\r\n\r\nconst supported = new Set([\r\n  'github',\r\n  'gitee',\r\n  'gitlab',\r\n  'bitbucket',\r\n  'git.sr.ht'\r\n])\r\n\r\n// \u6784\u9020\u4E0B\u8F7D\u5BF9\u8C61\r\nfunction normalize(store) {\r\n  let regex =\r\n    /^(?:(github|gitee|gitlab|bitbucket):)?(?:(.+):)?([^/]+)\\/([^#]+)(?:#(.+))?$/\r\n  let match = regex.exec(store)\r\n  let type = (match[1] || 'github').replace(/\\.(com|org)$/, '')\r\n  let domain = match[2] || null\r\n  let user = match[3]\r\n  let name = match[4]\r\n  let branch = match[5] || 'main'\r\n\r\n  if (domain === null) {\r\n    domain = `${type}.${type === 'bitbucket' ? 'org' : 'com'}`\r\n  }\r\n  let url = `https://${domain}/${user}/${name}`\r\n  return { type, domain, user, name, branch, url }\r\n}\r\n\r\nfunction parse(src) {\r\n  const match =\r\n    /^(?:(?:https:\\/\\/)?([^:/]+\\.[^:/]+)\\/|git@([^:/]+)[:/]|([^/]+):)?([^/\\s]+)\\/([^/\\s#]+)(?:((?:\\/[^/\\s#]+)+))?(?:\\/)?(?:#(.+))?/.exec(\r\n      src\r\n    )\r\n  if (!match) {\r\n    // throw new DegitError(`could not parse ${src}`, {\r\n    //   code: 'BAD_SRC'\r\n    // })\r\n  }\r\n\r\n  const site = (match[1] || match[2] || match[3] || 'github').replace(\r\n    /\\.(com|org)$/,\r\n    ''\r\n  )\r\n  if (!supported.has(site)) {\r\n    // throw new DegitError(\r\n    //   `degit supports GitHub, GitLab, Sourcehut and BitBucket`,\r\n    //   {\r\n    //     code: 'UNSUPPORTED_HOST'\r\n    //   }\r\n    // )\r\n  }\r\n\r\n  const user = match[4]\r\n  const name = match[5].replace(/\\.git$/, '')\r\n  const subdir = match[6]\r\n  const ref = match[7] || 'HEAD'\r\n\r\n  const domain = `${site}.${\r\n    site === 'bitbucket' ? 'org' : site === 'git.sr.ht' ? '' : 'com'\r\n  }`\r\n  const url = `https://${domain}/${user}/${name}`\r\n  const ssh = `git@${domain}:${user}/${name}`\r\n\r\n  const mode = supported.has(site) ? 'tar' : 'git'\r\n\r\n  return { site, user, name, ref, url, ssh, subdir, mode }\r\n}\r\n", "import fs from 'fs'\r\nimport path from 'path'\r\nimport { homedir, tmpdir } from 'os'\r\nimport child_process from 'child_process'\r\nexport const base = path.join(homedir() || tmpdir())\r\n\r\nexport function mkdirp(dir) {\r\n  const parent = path.dirname(dir)\r\n  if (parent === dir) return\r\n\r\n  mkdirp(parent)\r\n\r\n  try {\r\n    fs.mkdirSync(dir)\r\n  } catch (err) {\r\n    if (err.code !== 'EEXIST') throw err\r\n  }\r\n}\r\n\r\nexport function exec(command) {\r\n  return new Promise((resolve, reject) => {\r\n    child_process.exec(command, (err, stdout, stderr) => {\r\n      if (err) {\r\n        reject(err)\r\n        return\r\n      }\r\n      resolve({ stdout, stderr })\r\n    })\r\n  })\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA,gBAAe;;;ACCf,kBAAiB;AACjB,gBAAgC;AAChC,2BAA0B;AACnB,IAAM,OAAO,YAAAA,QAAK,SAAK,mBAAQ,SAAK,kBAAO,CAAC;AAe5C,SAAS,KAAK,SAAS;AAC5B,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,yBAAAC,QAAc,KAAK,SAAS,CAAC,KAAK,QAAQ,WAAW;AACnD,UAAI,KAAK;AACP,eAAO,GAAG;AACV;AAAA,MACF;AACA,cAAQ,EAAE,QAAQ,OAAO,CAAC;AAAA,IAC5B,CAAC;AAAA,EACH,CAAC;AACH;;;ADzBA,OAAO,UAAU,SAAS,KAAK,KAAK,MAAM;AACxC,SAAO,IAAI,KAAK,KAAK,IAAI;AAC3B;AAKA,IAAM,OAAN,MAAW;AAAA,EACT,YAAY,KAAK,OAAO,CAAC,GAAG;AAC1B,SAAK,MAAM;AACX,SAAK,QAAQ,QAAQ,IAAI;AACzB,SAAK,QAAQ,KAAK,SAAS;AAE3B,SAAK,OAAO,UAAU,GAAG;AAAA,EAE3B;AAAA,EACA,MAAM,MAAM,MAAM;AAChB,YAAQ,IAAI,KAAK,IAAI;AACrB,QAAI;AAEF,WAAK,iBAAiB,IAAI;AAC1B,YAAM,KAAK,cAAc,IAAI;AAAA,IAC/B,SAAS,OAAP;AACA,YAAM;AAAA,IACR;AAAA,EAOF;AAAA,EACA,MAAM,iBAAiB,KAAK;AAC1B,QAAI;AACF,YAAM,QAAQ,UAAAC,QAAG,YAAY,GAAG;AAChC,UAAI,MAAM,SAAS,GAAG;AACpB,YAAI,KAAK,OAAO;AACd,gBAAM,KAAK,UAAU,KAAK;AAAA,QAC5B,OAAO;AAEL,gBAAM;AAAA,QACR;AAAA,MACF;AAAA,IACF,SAAS,KAAP;AACA,UAAI,IAAI,SAAS;AAAU,cAAM;AAAA,IACnC;AAAA,EACF;AAAA,EACA,MAAM,cAAc,MAAM;AACxB,UAAM,KAAK,aAAa,KAAK,KAAK,OAAO,MAAM;AAE/C,UAAM,KAAK,UAAU,OAAO,UAAU;AAAA,EACxC;AACF;AAWA,SAAS,UAAU,OAAO;AACxB,MAAI,QACF;AACF,MAAI,QAAQ,MAAM,KAAK,KAAK;AAC5B,MAAI,QAAQ,MAAM,MAAM,UAAU,QAAQ,gBAAgB,EAAE;AAC5D,MAAI,SAAS,MAAM,MAAM;AACzB,MAAI,OAAO,MAAM;AACjB,MAAI,OAAO,MAAM;AACjB,MAAI,SAAS,MAAM,MAAM;AAEzB,MAAI,WAAW,MAAM;AACnB,aAAS,GAAG,QAAQ,SAAS,cAAc,QAAQ;AAAA,EACrD;AACA,MAAI,MAAM,WAAW,UAAU,QAAQ;AACvC,SAAO,EAAE,MAAM,QAAQ,MAAM,MAAM,QAAQ,IAAI;AACjD;",
  "names": ["path", "child_process", "fs"]
}
